å‰è¨€
> -ğŸ€å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯BXuan_Yangï¼Œçƒ­çˆ±ç¼–ç¨‹ä¸ç¯®çƒçš„è½¯ä»¶å·¥ç¨‹å¤§äºŒå­¦ç”Ÿä¸€å
> -ğŸ“šå½“çˆ±ä¸ŠCoding&Studyingçš„é‚£ä¸€åˆ»...
> -ğŸƒâ€æ”¾å¼ƒä¸éš¾ï¼Œä½†åšæŒä¸€å®šå¾ˆé…·ã€‚
---

[toc]

# ğŸ”ã€LeetCodeæ¯æ—¥ä¸€é¢˜ã€‘

##  ğŸŸ103.äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†

[ä¼ é€é—¨](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/submissions/)

### ğŸ•éš¾åº¦ï¼šä¸­ç­‰

### ğŸŒ­é¢˜ç›®æè¿°

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **é”¯é½¿å½¢å±‚åºéå†** ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚


### ğŸ¿ç¤ºä¾‹ 

```java
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[3],[20,9],[15,7]]
    
ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[[1]]
    
ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

### ğŸ¥“æç¤º

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 2000]` å†…
- `-100 <= Node.val <= 100`

### ğŸ§‡ä»£ç ç¤ºä¾‹

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        // å…ˆä»å·¦åˆ°å³ï¼Œå†ä»å³åˆ°å·¦ï¼Œä»¥æ­¤éå†
        List<List<Integer>> res = new LinkedList<>();
        if (root == null){
            return res;
        }        
        // ä½¿ç”¨é˜Ÿåˆ—ç©ºé—´è¿›è¡Œå­˜å‚¨
        Queue<TreeNode> queue = new LinkedList<>();
        // è¡¨ç¤ºå±‚æ•°
        boolean flag = true;
        queue.offer(root);
        while (!queue.isEmpty()){
            int size = queue.size();
            LinkedList<Integer> tempList = new LinkedList<>();
            for (int i = 0; i < size; i++){
                TreeNode tempNode = queue.poll();
                if (flag){
                    tempList.addLast(tempNode.val);
                }else{
                    tempList.addFirst(tempNode.val);
                }
                if (tempNode.left != null){
                    queue.offer(tempNode.left);
                }
                if (tempNode.right != null){
                    queue.offer(tempNode.right);
                }
            }
            flag = !flag;
            res.add(tempList);
        }
        return res;
    }
}
```
### ğŸ§€æ€è·¯&&è¡¥å……çŸ¥è¯†

102.å±‚åºéå†