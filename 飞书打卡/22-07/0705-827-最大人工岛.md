å‰è¨€
> -ğŸ€å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯BXuan_Yangï¼Œçƒ­çˆ±ç¼–ç¨‹ä¸ç¯®çƒçš„è½¯ä»¶å·¥ç¨‹å¤§äºŒå­¦ç”Ÿä¸€å
> -ğŸ“šå½“çˆ±ä¸ŠCoding&Studyingçš„é‚£ä¸€åˆ»...
> -ğŸƒâ€æ”¾å¼ƒä¸éš¾ï¼Œä½†åšæŒä¸€å®šå¾ˆé…·ã€‚
---

[toc]

# ğŸ”ã€LeetCodeæ¯æ—¥ä¸€é¢˜ã€‘

##  ğŸŸ827.æœ€å¤§äººå·¥å²›

[ä¼ é€é—¨](https://leetcode.cn/problems/making-a-large-island/)

### ğŸ•éš¾åº¦ï¼šå›°éš¾

### ğŸŒ­é¢˜ç›®æè¿°

ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º n x n äºŒè¿›åˆ¶çŸ©é˜µ grid ã€‚æœ€å¤š åªèƒ½å°†ä¸€æ ¼ 0 å˜æˆ 1 ã€‚

è¿”å›æ‰§è¡Œæ­¤æ“ä½œåï¼Œgrid ä¸­æœ€å¤§çš„å²›å±¿é¢ç§¯æ˜¯å¤šå°‘ï¼Ÿ

å²›å±¿ ç”±ä¸€ç»„ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘ç›¸è¿çš„ 1 å½¢æˆã€‚


### ğŸ¿ç¤ºä¾‹ 

```java
ç¤ºä¾‹ 1:
è¾“å…¥: grid = [[1, 0], [0, 1]]
è¾“å‡º: 3
è§£é‡Š: å°†ä¸€æ ¼0å˜æˆ1ï¼Œæœ€ç»ˆè¿é€šä¸¤ä¸ªå°å²›å¾—åˆ°é¢ç§¯ä¸º 3 çš„å²›å±¿ã€‚
    
ç¤ºä¾‹ 2:
è¾“å…¥: grid = [[1, 1], [1, 0]]
è¾“å‡º: 4
è§£é‡Š: å°†ä¸€æ ¼0å˜æˆ1ï¼Œå²›å±¿çš„é¢ç§¯æ‰©å¤§ä¸º 4ã€‚
    
ç¤ºä¾‹ 3:
è¾“å…¥: grid = [[1, 1], [1, 1]]
è¾“å‡º: 4
è§£é‡Š: æ²¡æœ‰0å¯ä»¥è®©æˆ‘ä»¬å˜æˆ1ï¼Œé¢ç§¯ä¾ç„¶ä¸º 4ã€‚
```

### ğŸ¥“æç¤º

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 500`
- `grid[i][j]` ä¸º `0` æˆ– `1`

### ğŸ§‡ä»£ç ç¤ºä¾‹

```java
class Solution {
    int[] dr = new int[]{-1, 0, 1, 0};
    int[] dc = new int[]{0, -1, 0, 1};
    int[][] grid;
    int N;

    public int largestIsland(int[][] grid) {
        this.grid = grid;
        N = grid.length;

        int index = 2;
        int[] area = new int[N*N + 2];
        for (int r = 0; r < N; ++r)
            for (int c = 0; c < N; ++c)
                if (grid[r][c] == 1)
                    area[index] = dfs(r, c, index++);

        int ans = 0;
        for (int x: area) ans = Math.max(ans, x);
        for (int r = 0; r < N; ++r)
            for (int c = 0; c < N; ++c)
                if (grid[r][c] == 0) {
                    Set<Integer> seen = new HashSet();
                    for (Integer move: neighbors(r, c))
                        if (grid[move / N][move % N] > 1)
                            seen.add(grid[move / N][move % N]);

                    int bns = 1;
                    for (int i: seen) bns += area[i];
                    ans = Math.max(ans, bns);
                }

        return ans;
    }

    public int dfs(int r, int c, int index) {
        int ans = 1;
        grid[r][c] = index;
        for (Integer move: neighbors(r, c)) {
            if (grid[move / N][move % N] == 1) {
                grid[move / N][move % N] = index;
                ans += dfs(move / N, move % N, index);
            }
        }

        return ans;
    }

    public List<Integer> neighbors(int r, int c) {
        List<Integer> ans = new ArrayList();
        for (int k = 0; k < 4; ++k) {
            int nr = r + dr[k];
            int nc = c + dc[k];
            if (0 <= nr && nr < N && 0 <= nc && nc < N)
                ans.add(nr * N + nc);
        }

        return ans;
    }
}
```
### ğŸ§€æ€è·¯&&è¡¥å……çŸ¥è¯†